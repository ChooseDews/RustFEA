use std::io::{Write, BufWriter};
use crate::simulation::Simulation;
use crate::elements::{BrickElement, BaseElement, ElementType};
use std::collections::HashMap;


use hdf5::{Extents, File, Group, Result};
use nalgebra::Vector3;
use ndarray::{Array1, Array2, Axis};

//logging
use log::{info, debug, trace};



/// Writes a VTK file for a given simulation.
/// 
/// # Arguments
/// * `filename`: The path to the file where the VTK data will be written.
/// * `simulation`: The simulation data to be written to the VTK file.
/// 
/// # Returns
/// A `std::io::Result<()>` indicating the success or failure of the operation.
pub fn write_vtk(filename: &str, simulation: &Simulation) -> std::io::Result<()> {
    info!("Writing VTK file: {}", filename);

    let file = std::fs::File::create(filename)?;
    let mut file = BufWriter::new(file);

    // Write VTK header
    file.write_all(b"# vtk DataFile Version 2.0\nGenerated by Rust\nASCII\nDATASET UNSTRUCTURED_GRID\n")?;

    let nodes = simulation.nodes();
    // Write points (nodes)
    writeln!(file, "POINTS {} float", nodes.len())?;
    for node in nodes.iter() {
        writeln!(file, "{} {} {}", node.position.x, node.position.y, node.position.z)?;
    }

    let all_elements: &HashMap<usize, Box<dyn BaseElement>> = simulation.elements();
    let elements: Vec<&Box<dyn BaseElement>> = all_elements.iter().filter(|(_id, element)| element.type_name() == ElementType::Brick).map(|(_, element)| element).collect();

    let elements_size = elements.len();    // Write cells (elements)
    let total_list_entries = elements_size * 9; // 8 nodes per element + 1 value for the number of points in the cell
    writeln!(file, "CELLS {} {}", elements_size, total_list_entries)?;
    for elem in elements.iter() {
        if !elem.is_active() {
            continue;
        }
        file.write_all(b"8 ")?; // 8-node brick element
        for &id in elem.get_connectivity() {
            write!(file, "{} ", id)?; // VTK uses 0-based index
        }
        file.write_all(b"\n")?;
    }

    // Write cell types (12 for hexahedron in VTK)
    writeln!(file, "CELL_TYPES {}", elements_size)?;
    for _ in 0..elements_size {
        file.write_all(b"12\n")?;
    }

    // Write point data for nodal displacements
    writeln!(file, "POINT_DATA {}", nodes.len())?;
    writeln!(file, "VECTORS displacement float")?;
    for node in nodes.iter() {
        writeln!(file, "{} {} {}", node.displacement.x, node.displacement.y, node.displacement.z)?;
    }

    // Write boundary condition forces as vector field
    let load_vector = simulation.get_global_force();
    writeln!(file, "VECTORS force float")?;
    for node_id in 0..nodes.len() {
        let fx = if node_id * 3 < load_vector.len() { load_vector[node_id * 3] } else { 0.0 };
        let fy = if node_id * 3 + 1 < load_vector.len() { load_vector[node_id * 3 + 1] } else { 0.0 };
        let fz = if node_id * 3 + 2 < load_vector.len() { load_vector[node_id * 3 + 2] } else { 0.0 };
        writeln!(file, "{} {} {}", fx, fy, fz)?;
    }

    // Write force magnitude as scalar field
    writeln!(file, "SCALARS f_mag float")?;
    writeln!(file, "LOOKUP_TABLE default")?;
    for node_id in 0..nodes.len() {
        let fx = if node_id * 3 < load_vector.len() { load_vector[node_id * 3] } else { 0.0 };
        let fy = if node_id * 3 + 1 < load_vector.len() { load_vector[node_id * 3 + 1] } else { 0.0 };
        let fz = if node_id * 3 + 2 < load_vector.len() { load_vector[node_id * 3 + 2] } else { 0.0 };
        let f_mag = (fx * fx + fy * fy + fz * fz).sqrt();
        writeln!(file, "{}", f_mag)?;
    }

    // Write node_fields as scalar data
    let node_fields = &simulation.node_fields;
    for (name, field) in node_fields.iter() {
        writeln!(file, "SCALARS {} float", name)?;
        writeln!(file, "LOOKUP_TABLE default")?;
        for value in field.iter() {
            writeln!(file, "{}", value)?;
        }
    }
    Ok(())
}


// TODO: Add .vtkhdf support for single file output with smaller size


pub fn write_vtkhdf(filename: &str, simulation: &Simulation) -> std::io::Result<()> {

    println!("Writing VTKHDF file: {}", filename);

    let file = hdf5::File::create(filename).expect("Failed to create file");
    let root = file.create_group("VTKHDF").expect("Failed to create group");
    let val = hdf5::types::FixedAscii::<16>::from_ascii("UnstructuredGrid".as_bytes()).unwrap();
    let attr = root.new_attr::<hdf5::types::FixedAscii::<16>>().create("Type").expect("Failed to create attribute");
    attr.write_scalar(&val).expect("Failed to write attribute");

    root.new_attr_builder().with_data(&[2, 0]).create("Version").expect("Failed to create attribute");

    // Create NumberOfPoints dataset
    let n_points = simulation.nodes().len();
    let num_points_ds = root.new_dataset::<i64>().shape((1,)).create("NumberOfPoints").expect("Failed to create dataset");
    num_points_ds.write_raw(&[n_points as i64]).expect("Failed to write dataset");



    // Create Points dataset
    let n_points = simulation.nodes().len();
    let mut points_data = Array2::<f64>::zeros((n_points, 3));
    for (i, node) in simulation.nodes().iter().enumerate() {
        points_data[[i, 0]] = node.position.x;
        points_data[[i, 1]] = node.position.y;
        points_data[[i, 2]] = node.position.z;
    }
    let points_ds = root.new_dataset::<f64>().shape((n_points, 3)).create("Points").expect("Failed to create dataset");
    points_ds.write_raw(points_data.as_slice().unwrap()).expect("Failed to write dataset");


    //handle connectivity data
    let all_elements: &HashMap<usize, Box<dyn BaseElement>> = simulation.elements();
    let elements: Vec<&Box<dyn BaseElement>> = all_elements.iter().filter(|(_id, element)| element.type_name() == ElementType::Brick).map(|(_, element)| element).collect();
    let n_elements: usize = elements.len();

    let num_cells_ds = root.new_dataset::<i64>().shape((1,)).create("NumberOfCells").expect("Failed to create dataset");
    num_cells_ds.write_raw(&[n_elements as i64]).expect("Failed to write dataset");

    //NumberOfConnectivityIds dataset
    let num_connectivity_ids_ds = root.new_dataset::<i64>().shape((1,)).create("NumberOfConnectivityIds").expect("Failed to create dataset");
    num_connectivity_ids_ds.write_raw(&[8*n_elements as i64]).expect("Failed to write dataset");

    // Create Connectivity dataset
    let mut connectivity_data = Array2::<i64>::zeros((n_elements, 8));
    for (i, elem) in elements.iter().enumerate() {
        for (j, &id) in elem.get_connectivity().iter().enumerate() {
            connectivity_data[[i, j]] = id as i64;
        }
    }

    let extents = Extents::new(connectivity_data.len());
    let connectivity_ds = root.new_dataset::<i64>()
        .shape(extents)
        .create("Connectivity")
        .expect("Failed to create dataset");
    connectivity_ds.write(connectivity_data.as_slice().unwrap()).expect("Failed to write dataset");

    // Create Offsets dataset
    let mut offsets = Vec::with_capacity(n_elements+1);
    for i in 0..(n_elements+1) {
        offsets.push((i) * 8);  // 8 nodes per element
    }
    let extents = Extents::new(offsets.len());
    let offsets_ds = root.new_dataset::<i64>()
        .shape(extents)
        .create("Offsets")
        .expect("Failed to create dataset");
    offsets_ds.write(&offsets).expect("Failed to write dataset");

    // Create Types dataset
    let extents = Extents::new(n_elements);
    let types = vec![12u8; n_elements]; // 12 is the VTK type for hexahedron
    let types_ds = root.new_dataset::<u8>()  // Change the data type to u8
        .shape(extents)
        .create("Types")
        .expect("Failed to create dataset");
    types_ds.write(&types).expect("Failed to write dataset");


    //create PointData
    let point_data_group = root.create_group("PointData").expect("Failed to create group");
    let displacement_ds = point_data_group.new_dataset::<f64>().shape((n_points, 3)).create("Displacement").expect("Failed to create dataset");
    let u = simulation.nodes().iter().map(|node| node.displacement.as_slice()).collect::<Vec<&[f64]>>();
    displacement_ds.write_raw(u.concat().as_slice()).expect("Failed to write dataset");

    // Add boundary condition forces as vector field
    let load_vector = simulation.get_global_force();
    let mut force_data = Array2::<f64>::zeros((n_points, 3));
    let mut f_mag = Vec::with_capacity(n_points);
    
    for node_id in 0..n_points {
        let fx = if node_id * 3 < load_vector.len() { load_vector[node_id * 3] } else { 0.0 };
        let fy = if node_id * 3 + 1 < load_vector.len() { load_vector[node_id * 3 + 1] } else { 0.0 };
        let fz = if node_id * 3 + 2 < load_vector.len() { load_vector[node_id * 3 + 2] } else { 0.0 };
        
        force_data[[node_id, 0]] = fx;
        force_data[[node_id, 1]] = fy;
        force_data[[node_id, 2]] = fz;
        f_mag.push((fx * fx + fy * fy + fz * fz).sqrt());
    }
    let force_ds = point_data_group.new_dataset::<f64>().shape((n_points, 3)).create("force").expect("Failed to create dataset");
    force_ds.write_raw(force_data.as_slice().unwrap()).expect("Failed to write dataset");

    // Add force magnitude as scalar field
    let f_mag_ds = point_data_group.new_dataset::<f64>().shape((n_points,)).create("f_mag").expect("Failed to create dataset");
    f_mag_ds.write_raw(f_mag.as_slice()).expect("Failed to write dataset");

    //handle all node fields
    let node_fields = &simulation.node_fields;
    for (name, field) in node_fields.iter() {
        let field_ds = point_data_group.new_dataset::<f64>().shape((n_points,)).create(name.as_str()).expect("Failed to create dataset");
        field_ds.write_raw(field.as_slice()).expect("Failed to write dataset");
    }


    Ok(())
}

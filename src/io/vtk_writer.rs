use std::fs::File;
use std::io::{Write, BufWriter};
use crate::simulation::Simulation;
use crate::elements::{BrickElement, BaseElement, ElementType};
use std::collections::HashMap;

//logging
use log::{info, debug, trace};

/// Writes a VTK file for a given simulation.
/// 
/// # Arguments
/// * `filename`: The path to the file where the VTK data will be written.
/// * `simulation`: The simulation data to be written to the VTK file.
/// 
/// # Returns
/// A `std::io::Result<()>` indicating the success or failure of the operation.
pub fn write_vtk(filename: &str, simulation: &Simulation) -> std::io::Result<()> {
    info!("Writing VTK file: {}", filename);

    let file = File::create(filename)?;
    let mut file = BufWriter::new(file);

    // Write VTK header
    file.write_all(b"# vtk DataFile Version 2.0\nGenerated by Rust\nASCII\nDATASET UNSTRUCTURED_GRID\n")?;

    let nodes = simulation.nodes();
    // Write points (nodes)
    writeln!(file, "POINTS {} float", nodes.len())?;
    for node in nodes.iter() {
        writeln!(file, "{} {} {}", node.position.x, node.position.y, node.position.z)?;
    }

    let all_elements: &HashMap<usize, Box<dyn BaseElement>> = simulation.elements();
    let elements: Vec<&Box<dyn BaseElement>> = all_elements.iter().filter(|(_id, element)| element.type_name() == ElementType::Brick).map(|(_, element)| element).collect();

    let elements_size = elements.len();    // Write cells (elements)
    let total_list_entries = elements_size * 9; // 8 nodes per element + 1 value for the number of points in the cell
    writeln!(file, "CELLS {} {}", elements_size, total_list_entries)?;
    for elem in elements.iter() {
        if !elem.is_active() {
            continue;
        }
        file.write_all(b"8 ")?; // 8-node brick element
        for &id in elem.get_connectivity() {
            write!(file, "{} ", id)?; // VTK uses 0-based index
        }
        file.write_all(b"\n")?;
    }

    // Write cell types (12 for hexahedron in VTK)
    writeln!(file, "CELL_TYPES {}", elements_size)?;
    for _ in 0..elements_size {
        file.write_all(b"12\n")?;
    }

    // Write point data for nodal displacements
    writeln!(file, "POINT_DATA {}", nodes.len())?;
    writeln!(file, "VECTORS displacement float")?;
    for node in nodes.iter() {
        writeln!(file, "{} {} {}", node.displacement.x, node.displacement.y, node.displacement.z)?;
    }

    // Write node_fields as scalar data
    let node_fields = &simulation.node_feilds; // Consider renaming `node_feilds` to `node_fields`
    for (name, field) in node_fields.iter() {
        writeln!(file, "SCALARS {} float", name)?;
        writeln!(file, "LOOKUP_TABLE default")?;
        for value in field.iter() {
            writeln!(file, "{}", value)?;
        }
    }
    Ok(())
}